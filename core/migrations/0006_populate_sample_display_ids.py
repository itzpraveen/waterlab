# Generated by Django 5.2.1 on 2025-06-01 18:19

from django.db import migrations
from django.utils import timezone

def generate_display_ids(apps, schema_editor):
    Sample = apps.get_model('core', 'Sample')
    # Order by primary key to ensure a consistent processing order
    # This helps in assigning sequential IDs if multiple samples were created in the same year
    # without a display_id yet.
    samples_to_update = Sample.objects.filter(display_id__isnull=True).order_by('sample_id') 
    
    # Keep track of the last sequence number for each year
    year_sequences = {}

    for sample in samples_to_update:
        # Determine the year for the ID. Use collection_datetime if available, otherwise current year.
        # This is important if backfilling very old data. For simplicity, we'll use
        # the year of the sample's collection_datetime. If that's not set,
        # it might indicate an issue, but we'll default to current year for the ID.
        # However, the model's save method uses timezone.now().year.
        # For consistency during this backfill, let's stick to how new IDs are generated.
        # The model's save method uses timezone.now().year for the prefix.
        # To ensure this data migration is robust for historical data,
        # it's better to derive the year from the sample's creation/collection time if possible.
        # Let's assume collection_datetime is reliable for determining the year part of the ID.
        
        if sample.collection_datetime:
            year_for_id = sample.collection_datetime.year
        else:
            # Fallback if collection_datetime is somehow null for an existing record
            # This case should be rare if the model enforces collection_datetime
            year_for_id = timezone.now().year 

        prefix = f"WL{year_for_id}-"

        if year_for_id not in year_sequences:
            # Check if there are any existing display_ids for this year to start sequence correctly
            last_sample_this_year = Sample.objects.filter(display_id__startswith=prefix).order_by('display_id').last()
            if last_sample_this_year and last_sample_this_year.display_id:
                try:
                    year_sequences[year_for_id] = int(last_sample_this_year.display_id.split('-')[-1])
                except (IndexError, ValueError):
                    year_sequences[year_for_id] = 0 # Start from 0, will become 1
            else:
                year_sequences[year_for_id] = 0 # Start from 0, will become 1
        
        year_sequences[year_for_id] += 1
        new_sequence = year_sequences[year_for_id]
        
        sample.display_id = f"{prefix}{new_sequence:04d}"
        sample.save(update_fields=['display_id'])

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0005_sample_display_id_alter_sample_sample_id'),
    ]

    operations = [
        migrations.RunPython(generate_display_ids, migrations.RunPython.noop),
    ]
